# Vue3æºä»£ç è°ƒè¯•

## æºç ç¼–è¯‘-å¼€å‘ç¯å¢ƒ

vue3 æºç çš„`package.json`ä¸­ä¸¤ä¸ªè¿è¡Œè„šæœ¬å¦‚ä¸‹ï¼Œå¯ä»¥çœ‹åˆ°è¿è¡Œçš„æ˜¯`script`æ–‡ä»¶å¤¹ä¸‹çš„ä¸¤ä¸ªjsæ–‡ä»¶ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ¥çœ‹çœ‹è¿™ä¸¤ä¸ªæ–‡ä»¶åšäº†ä¸€äº›ä»€ä¹ˆäº‹ã€‚

```json
"dev": "node scripts/dev.js",
"build": "node scripts/build.js",
```

`dev.js`å†…å®¹å¦‚ä¸‹ï¼Œå¯ä»¥çœ‹åˆ°devæ¨¡å¼ä¸‹ä»£ç æ˜¯ç”¨`esbuild`è¿›è¡Œæ‰“åŒ…ï¼Œå…¥å£æ–‡ä»¶æ˜¯`../packages/vue/src/index.ts`ï¼Œåç»­æ¢ç´¢vue3æºç çš„å…¥å£å°±åœ¨æ­¤ï¼š

```js
// Using esbuild for faster dev builds.
// We are still using Rollup for production builds because it generates
// smaller files w/ better tree-shaking.

// @ts-check
const { build } = require('esbuild')
const nodePolyfills = require('@esbuild-plugins/node-modules-polyfill')
const { resolve, relative } = require('path')
const args = require('minimist')(process.argv.slice(2))

// targetè¯»å–å‘½ä»¤è¡Œå‚æ•°å¯»æ‰¾æ‰“åŒ…å…¥å£æ–‡ä»¶ï¼Œæ²¡æœ‰çš„è¯é»˜è®¤å°±æ˜¯../packages/vue/src/index.ts
const target = args._[0] || 'vue'
const format = args.f || 'global'
const inlineDeps = args.i || args.inline
const pkg = require(resolve(__dirname, `../packages/${target}/package.json`))

// resolve output
const outputFormat = format.startsWith('global')
  ? 'iife'
  : format === 'cjs'
  ? 'cjs'
  : 'esm'

const postfix = format.endsWith('-runtime')
  ? `runtime.${format.replace(/-runtime$/, '')}`
  : format

const outfile = resolve(
  __dirname,
  `../packages/${target}/dist/${
    target === 'vue-compat' ? `vue` : target
  }.${postfix}.js`
)
const relativeOutfile = relative(process.cwd(), outfile)

// resolve externals
// TODO this logic is largely duplicated from rollup.config.js
let external = []
if (!inlineDeps) {
  // cjs & esm-bundler: external all deps
  if (format === 'cjs' || format.includes('esm-bundler')) {
    external = [
      ...external,
      ...Object.keys(pkg.dependencies || {}),
      ...Object.keys(pkg.peerDependencies || {}),
      // for @vue/compiler-sfc / server-renderer
      'path',
      'url',
      'stream'
    ]
  }

  if (target === 'compiler-sfc') {
    const consolidateDeps = require.resolve('@vue/consolidate/package.json', {
      paths: [resolve(__dirname, `../packages/${target}/`)]
    })
    external = [
      ...external,
      ...Object.keys(require(consolidateDeps).devDependencies),
      'fs',
      'vm',
      'crypto',
      'react-dom/server',
      'teacup/lib/express',
      'arc-templates/dist/es5',
      'then-pug',
      'then-jade'
    ]
  }
}

// ã€ä½¿ç”¨esbuildæ‰“åŒ…ã€‘
build({
  entryPoints: [resolve(__dirname, `../packages/${target}/src/index.ts`)],
  outfile,
  bundle: true,
  external,
  sourcemap: true,
  format: outputFormat,
  globalName: pkg.buildOptions?.name,
  platform: format === 'cjs' ? 'node' : 'browser',
  plugins:
    format === 'cjs' || pkg.buildOptions?.enableNonBrowserBranches
      ? [nodePolyfills.default()]
      : undefined,
  // æä¾›äº†ä¸€ç§ç”¨å¸¸é‡è¡¨è¾¾å¼æ›¿æ¢å…¨å±€æ ‡è¯†ç¬¦çš„æ–¹æ³•ã€‚ å®ƒå¯ä»¥åœ¨ä¸æ”¹å˜ä»£ç æœ¬èº«çš„æƒ…å†µä¸‹æ”¹å˜æŸäº›æ„å»ºä¹‹é—´ä»£ç çš„è¡Œä¸º
  define: {
    __COMMIT__: `"dev"`,
    __VERSION__: `"${pkg.version}"`,
    __DEV__: `true`,
    __TEST__: `false`,
    __BROWSER__: String(
      format !== 'cjs' && !pkg.buildOptions?.enableNonBrowserBranches
    ),
    __GLOBAL__: String(format === 'global'),
    __ESM_BUNDLER__: String(format.includes('esm-bundler')),
    __ESM_BROWSER__: String(format.includes('esm-browser')),
    __NODE_JS__: String(format === 'cjs'),
    __SSR__: String(format === 'cjs' || format.includes('esm-bundler')),
    __COMPAT__: String(target === 'vue-compat'),
    __FEATURE_SUSPENSE__: `true`,
    __FEATURE_OPTIONS_API__: `true`,
    __FEATURE_PROD_DEVTOOLS__: `false`
  },
  watch: {
    onRebuild(error) {
      if (!error) console.log(`rebuilt: ${relativeOutfile}`)
    }
  }
}).then(() => {
  console.log(`watching: ${relativeOutfile}`)
})
```

## æºç ç¼–è¯‘-ç”Ÿäº§ç¯å¢ƒ

`build.js`å†…å®¹å¦‚ä¸‹ï¼Œå¯ä»¥çœ‹åˆ°ç”Ÿäº§æ‰“åŒ…ç”¨çš„æ˜¯`rollup`ï¼Œå¹¶ä¸”`packages`æ–‡ä»¶å¤¹ä¸‹æœ‰å¤šä¸ªç‹¬ç«‹çš„ä»£ç ä»“åº“ï¼Œä¼šé€ä¸ªå¯¹æ¯ä¸ªä»“åº“è¿›è¡Œæ‰“åŒ…ï¼š

```js
/*
Produces production builds and stitches together d.ts files.

To specify the package to build, simply pass its name and the desired build
formats to output (defaults to `buildOptions.formats` specified in that package,
or "esm,cjs"):


# name supports fuzzy match. will build all packages with name containing "dom":
nr build dom

# specify the format to output
nr build core --formats cjs

*/

const fs = require('fs-extra')
const path = require('path')
const chalk = require('chalk')
const execa = require('execa')
const { gzipSync } = require('zlib')
const { compress } = require('brotli')
const { targets: allTargets, fuzzyMatchTarget } = require('./utils')

const args = require('minimist')(process.argv.slice(2))
const targets = args._
const formats = args.formats || args.f
const devOnly = args.devOnly || args.d
const prodOnly = !devOnly && (args.prodOnly || args.p)
const sourceMap = args.sourcemap || args.s
const isRelease = args.release
const buildTypes = args.t || args.types || isRelease
const buildAllMatching = args.all || args.a
const commit = execa.sync('git', ['rev-parse', 'HEAD']).stdout.slice(0, 7)

run()

async function run() {
  if (isRelease) {
    // remove build cache for release builds to avoid outdated enum values
    await fs.remove(path.resolve(__dirname, '../node_modules/.rts2_cache'))
  }
  // ã€è¿›å…¥buildAllæ–¹æ³•ã€‘
  if (!targets.length) {
    await buildAll(allTargets)
    checkAllSizes(allTargets)
  } else {
    await buildAll(fuzzyMatchTarget(targets, buildAllMatching))
    checkAllSizes(fuzzyMatchTarget(targets, buildAllMatching))
  }
}

// ã€è¿›å…¥runParallelæ–¹æ³•ï¼Œå…¥å‚æœ‰ï¼šç³»ç»Ÿcpuæ•°ï¼Œç›®æ ‡èµ„æºï¼Œbuildæ–¹æ³•ã€‘
async function buildAll(targets) {
  await runParallel(require('os').cpus().length, targets, build)
}

async function runParallel(maxConcurrency, source, iteratorFn) {
  console.log('ğŸ¥’ ~ file: build.js:57 ~ runParallel ~ iteratorFn:', iteratorFn)
  console.log('ğŸ¥’ ~ file: build.js:57 ~ runParallel ~ source:', source)
  console.log(
    'ğŸ¥’ ~ file: build.js:57 ~ runParallel ~ maxConcurrency:',
    maxConcurrency
  )
  const ret = []//ã€æ‰€æœ‰ä»»åŠ¡ã€‘
  const executing = []//ã€æ­£åœ¨å¹¶å‘æ‰§è¡Œä¸­çš„ä»»åŠ¡ï¼Œè£…è½½çš„æ˜¯æ¯ä¸ªä»“åº“æ‰“åŒ…è¿™ä¸ªå¼‚æ­¥ä»»åŠ¡å®Œæˆåâ€œåˆ é™¤â€çš„ä»»åŠ¡ã€‘
  for (const item of source) {
    // ã€éå†æ‰€æœ‰éœ€è¦æ‰“åŒ…çš„ä»“åº“ï¼Œæ¯ä¸€ä¸ªä»“åº“éƒ½æ„é€ ä¸€ä¸ªpromiseä»»åŠ¡å¹¶pushåˆ°retæ•°ç»„ä¸­ã€‘
    const p = Promise.resolve().then(() => iteratorFn(item, source))
    ret.push(p)

    // ã€å¦‚æœæœ€å¤§å¹¶å‘ä»»åŠ¡æ•°æ¯”ä»“åº“æ•°å°ï¼Œé‚£å°±è¦â€œç«äº‰ä¸Šå²—â€ã€‘
    if (maxConcurrency <= source.length) {
      // ã€å½“å‰è¿™ä¸ªå¼‚æ­¥ä»»åŠ¡ä¸€æ—¦æ‰§è¡Œå®Œå°±ä»executingé˜Ÿåˆ—é‡Œåˆ æ‰ã€‘
      const e = p.then(() => executing.splice(executing.indexOf(e), 1))
      executing.push(e)

      if (executing.length >= maxConcurrency) {
        // ã€æ­£åœ¨å¹¶å‘æ‰§è¡Œä¸­çš„ä»»åŠ¡æ•°å¤§äºç­‰äºæœ€å¤§å¹¶å‘æ•°ï¼Œé‚£å°±ç”¨Promise.raceæ–¹æ³•å‰”é™¤æ‰æœ€å…ˆæ‰§è¡Œå®Œçš„å¼‚æ­¥ä»»åŠ¡ï¼Œè¿™å°±æ˜¯å¦‚ä½•å§‹ç»ˆæ§åˆ¶ä¸è¶…è¿‡æœ€å¤§å¹¶å‘æ•°ã€‘
        await Promise.race(executing)
      }
    }
  }
  // ã€æœ€å¤§ä»»åŠ¡å¹¶å‘æ•°æ¯”ä»“åº“æ•°é‡å¤§ï¼Œç›´æ¥ç”¨Promise.allæ‰§è¡Œæ‰æ‰€æœ‰å¼‚æ­¥ä»»åŠ¡ã€‘
  return Promise.all(ret)
}

async function build(target) {
  // ã€æ‰“åŒ…æ–¹æ³•æ ¸å¿ƒå†…å®¹ï¼Œç”¨rollupæ‰“åŒ…ã€‘
  const pkgDir = path.resolve(`packages/${target}`)
  const pkg = require(`${pkgDir}/package.json`)

  // if this is a full build (no specific targets), ignore private packages
  if ((isRelease || !targets.length) && pkg.private) {
    return
  }

  // if building a specific format, do not remove dist.
  if (!formats) {
    await fs.remove(`${pkgDir}/dist`)
  }

  const env =
    (pkg.buildOptions && pkg.buildOptions.env) ||
    (devOnly ? 'development' : 'production')
  await execa(
    'rollup',
    [
      '-c',
      '--environment',
      [
        `COMMIT:${commit}`,
        `NODE_ENV:${env}`,
        `TARGET:${target}`,
        formats ? `FORMATS:${formats}` : ``,
        buildTypes ? `TYPES:true` : ``,
        prodOnly ? `PROD_ONLY:true` : ``,
        sourceMap ? `SOURCE_MAP:true` : ``
      ]
        .filter(Boolean)
        .join(',')
    ],
    { stdio: 'inherit' }
  )

  if (buildTypes && pkg.types) {
    console.log()
    console.log(
      chalk.bold(chalk.yellow(`Rolling up type definitions for ${target}...`))
    )

    // build types
    const { Extractor, ExtractorConfig } = require('@microsoft/api-extractor')

    const extractorConfigPath = path.resolve(pkgDir, `api-extractor.json`)
    const extractorConfig =
      ExtractorConfig.loadFileAndPrepare(extractorConfigPath)
    const extractorResult = Extractor.invoke(extractorConfig, {
      localBuild: true,
      showVerboseMessages: true
    })

    if (extractorResult.succeeded) {
      // concat additional d.ts to rolled-up dts
      const typesDir = path.resolve(pkgDir, 'types')
      if (await fs.exists(typesDir)) {
        const dtsPath = path.resolve(pkgDir, pkg.types)
        const existing = await fs.readFile(dtsPath, 'utf-8')
        const typeFiles = await fs.readdir(typesDir)
        const toAdd = await Promise.all(
          typeFiles.map(file => {
            return fs.readFile(path.resolve(typesDir, file), 'utf-8')
          })
        )
        await fs.writeFile(dtsPath, existing + '\n' + toAdd.join('\n'))
      }
      console.log(
        chalk.bold(chalk.green(`API Extractor completed successfully.`))
      )
    } else {
      console.error(
        `API Extractor completed with ${extractorResult.errorCount} errors` +
          ` and ${extractorResult.warningCount} warnings`
      )
      process.exitCode = 1
    }

    await fs.remove(`${pkgDir}/dist/packages`)
  }
}

function checkAllSizes(targets) {
  if (devOnly || (formats && !formats.includes('global'))) {
    return
  }
  console.log()
  for (const target of targets) {
    checkSize(target)
  }
  console.log()
}

function checkSize(target) {
  const pkgDir = path.resolve(`packages/${target}`)
  checkFileSize(`${pkgDir}/dist/${target}.global.prod.js`)
  if (!formats || formats.includes('global-runtime')) {
    checkFileSize(`${pkgDir}/dist/${target}.runtime.global.prod.js`)
  }
}

function checkFileSize(filePath) {
  if (!fs.existsSync(filePath)) {
    return
  }
  const file = fs.readFileSync(filePath)
  const minSize = (file.length / 1024).toFixed(2) + 'kb'
  const gzipped = gzipSync(file)
  const gzippedSize = (gzipped.length / 1024).toFixed(2) + 'kb'
  const compressed = compress(file)
  const compressedSize = (compressed.length / 1024).toFixed(2) + 'kb'
  console.log(
    `${chalk.gray(
      chalk.bold(path.basename(filePath))
    )} min:${minSize} / gzip:${gzippedSize} / brotli:${compressedSize}`
  )
}
```

å…¶ä¸­æœ€å…³é”®çš„å†…å®¹æ˜¯æ‰§è¡Œäº†ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡`runParallel`æ–¹æ³•ï¼Œæ‰“å°çš„å†…å®¹å¦‚ä¸‹ï¼Œå¯ä»¥çœ‹åˆ°`runParallel`æ–¹æ³•å…¶å®å°±æ˜¯éå†`source`å¹¶è°ƒç”¨`build`æ–¹æ³•è¿›è¡Œæ‰“åŒ…ï¼Œæœ€å¤§å¹¶å‘ä»»åŠ¡æ•°é‡æ˜¯ç³»ç»Ÿçš„cpuæ•°(TODO:çº¿ç¨‹æ•°ï¼Ÿ)ã€‚

1. éå†`source`ï¼ŒåŒ…è£…`const p = Promise.resolve().then(() => iteratorFn(item, source))`å¹¶pushåˆ°retæ•°ç»„ä¸­
2. å¦‚æœ`maxConcurrency`å°äºç­‰äº`source.length`ä¹Ÿå°±æ˜¯æ€»ä»»åŠ¡æ•°ï¼ŒåŒ…è£…`const e = p.then(() => executing.splice(executing.indexOf(e), 1))`å¹¶pushåˆ°`executing`æ•°ç»„ï¼Œè¿™ä¸ªPromiseå…¶å®ä»£è¡¨æ¯ä¸ªä»»åŠ¡çš„å®Œæˆå¹¶ä»`executing`åˆ é™¤å½“å‰ä»»åŠ¡
3. ä¸€æ—¦`executing`å¤§äºç­‰äºæœ€å¤§å¹¶å‘æ•°`maxConcurrency`ï¼Œå°±ç”¨`Promise.race(executing)`ç­‰å¾…ä¸€ä¸ªä»»åŠ¡çš„å®Œæˆï¼ˆå®Œæˆåä¼šä»executingæ•°ç»„ä¸­åˆ æ‰è‡ªèº«ï¼‰ï¼Œè¿™æ ·å°±èƒ½æ§åˆ¶`executing`æ•°é‡å§‹ç»ˆä¸è¶…è¿‡æœ€å¤§å¹¶å‘æ•°`maxConcurrency`

```js
ğŸ¥’ ~ file: build.js:57 ~ runParallel ~ iteratorFn: [AsyncFunction: build]
ğŸ¥’ ~ file: build.js:57 ~ runParallel ~ source: [
  'compiler-core',
  'compiler-dom',
  'compiler-sfc',
  'compiler-ssr',
  'reactivity',
  'reactivity-transform',
  'runtime-core',
  'runtime-dom',
  'server-renderer',
  'shared',
  'template-explorer',
  'vue',
  'vue-compat'
]
ğŸ¥’ ~ file: build.js:57 ~ runParallel ~ maxConcurrency: 4

run()

async function run() {
  if (isRelease) {
    // remove build cache for release builds to avoid outdated enum values
    await fs.remove(path.resolve(__dirname, '../node_modules/.rts2_cache'))
  }
  if (!targets.length) {
    await buildAll(allTargets)
    checkAllSizes(allTargets)
  } else {
    await buildAll(fuzzyMatchTarget(targets, buildAllMatching))
    checkAllSizes(fuzzyMatchTarget(targets, buildAllMatching))
  }
}

async function buildAll(targets) {
  await runParallel(require('os').cpus().length, targets, build)
}

async function runParallel(maxConcurrency, source, iteratorFn) {
  console.log('ğŸ¥’ ~ file: build.js:57 ~ runParallel ~ iteratorFn:', iteratorFn)
  console.log('ğŸ¥’ ~ file: build.js:57 ~ runParallel ~ source:', source)
  console.log(
    'ğŸ¥’ ~ file: build.js:57 ~ runParallel ~ maxConcurrency:',
    maxConcurrency
  )
  const ret = []//ã€æ‰€æœ‰ä»»åŠ¡ã€‘
  const executing = []//ã€æ­£åœ¨å¹¶å‘æ‰§è¡Œä¸­çš„ä»»åŠ¡ï¼Œè£…è½½çš„æ˜¯æ¯ä¸ªä»“åº“æ‰“åŒ…è¿™ä¸ªå¼‚æ­¥ä»»åŠ¡å®Œæˆåâ€œåˆ é™¤â€çš„ä»»åŠ¡ã€‘
  for (const item of source) {
    // ã€éå†æ‰€æœ‰éœ€è¦æ‰“åŒ…çš„ä»“åº“ï¼Œæ¯ä¸€ä¸ªä»“åº“éƒ½æ„é€ ä¸€ä¸ªpromiseä»»åŠ¡å¹¶pushåˆ°retæ•°ç»„ä¸­ã€‘
    const p = Promise.resolve().then(() => iteratorFn(item, source))
    ret.push(p)

    // ã€å¦‚æœæœ€å¤§å¹¶å‘ä»»åŠ¡æ•°æ¯”ä»“åº“æ•°å°ï¼Œé‚£å°±è¦â€œç«äº‰ä¸Šå²—â€ã€‘
    if (maxConcurrency <= source.length) {
      // ã€å½“å‰è¿™ä¸ªå¼‚æ­¥ä»»åŠ¡ä¸€æ—¦æ‰§è¡Œå®Œå°±ä»executingé˜Ÿåˆ—é‡Œåˆ æ‰ã€‘
      const e = p.then(() => executing.splice(executing.indexOf(e), 1))
      executing.push(e)

      if (executing.length >= maxConcurrency) {
        // ã€æ­£åœ¨å¹¶å‘æ‰§è¡Œä¸­çš„ä»»åŠ¡æ•°å¤§äºç­‰äºæœ€å¤§å¹¶å‘æ•°ï¼Œé‚£å°±ç”¨Promise.raceæ–¹æ³•å‰”é™¤æ‰æœ€å…ˆæ‰§è¡Œå®Œçš„å¼‚æ­¥ä»»åŠ¡ï¼Œè¿™å°±æ˜¯å¦‚ä½•å§‹ç»ˆæ§åˆ¶ä¸è¶…è¿‡æœ€å¤§å¹¶å‘æ•°ã€‘
        await Promise.race(executing)
      }
    }
  }
  // ã€æœ€å¤§ä»»åŠ¡å¹¶å‘æ•°æ¯”ä»“åº“æ•°é‡å¤§ï¼Œç›´æ¥ç”¨Promise.allæ‰§è¡Œæ‰æ‰€æœ‰å¼‚æ­¥ä»»åŠ¡ã€‘
  return Promise.all(ret)
}
```

## æºç è°ƒè¯•

1. ç¬¬ä¸€æ­¥æ‰“å¼€`sourcemap`

```json
"dev": "node scripts/dev.js --sourcemap"
```

2. è¿è¡Œ`npm run serve`
3. åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€é¡¹ç›®ä¸­`vue`æ–‡ä»¶å¤¹ä¸‹çš„`examples`é‡Œçš„ç¤ºä¾‹ä»£ç æˆ–è€…è‡ªå·±å†™ä¸€ä¸ªç”¨ä¾‹éƒ½å¯ä»¥
4. æ·»åŠ æ–­ç‚¹è¿›è¡Œè°ƒè¯•ï¼Œå¦‚æœè¦è¿›è¡Œä¸€äº›ä»£ç ä¿®æ”¹æˆ–è€…æ‰“å°ï¼Œæ¯æ¬¡ä¿®æ”¹ä¹‹åéœ€è¦æ‰§è¡Œ`npm run dev`é‡æ–°æ‰“åŒ…ä»£ç 

![vue](./assets/vue.png)

## Vueé¡¹ç›®ä¸­è°ƒè¯•Vueæºç 

è¦è°ƒè¯•é€šè¿‡ `create-vue` åˆ›å»ºçš„ `Vue` é¡¹ç›®çš„ `Vue` æºç ï¼Œå¯ä»¥æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤è¿›è¡Œï¼š

### 1. å®‰è£…å’Œè®¾ç½® Vue é¡¹ç›®

é¦–å…ˆï¼Œé€šè¿‡ `create-vue` åˆ›å»ºä¸€ä¸ªæ–°çš„ `Vue` é¡¹ç›®ï¼š

```bash
npm init vue@latest
```

æŒ‰ç…§æç¤ºé…ç½®é¡¹ç›®ï¼Œç„¶åè¿›å…¥é¡¹ç›®ç›®å½•å¹¶å®‰è£…ä¾èµ–ï¼š

```bash
cd your-project-name
pnpm install
```

### 2. å…‹éš† Vue æºç 

åœ¨ä½ å¸Œæœ›è°ƒè¯•çš„åœ°æ–¹å…‹éš† `Vue` ä»“åº“ï¼š

```bash
git clone https://github.com/vuejs/vue-next.git
```

è¿›å…¥å…‹éš†çš„ä»“åº“å¹¶å®‰è£…ä¾èµ–ï¼š

```bash
cd vue-next
pnpm install
```

### 3. æ„å»º Vue æºç 

æ„å»º `Vue` çš„æºç ï¼Œä»¥ä¾¿ä½ å¯ä»¥åœ¨ä½ çš„é¡¹ç›®ä¸­ä½¿ç”¨å®ƒï¼š

```bash
pnpm run build
```

### 4. åœ¨ Vue é¡¹ç›®ä¸­ä½¿ç”¨æœ¬åœ°æ„å»ºçš„ Vue æºç 

ä½ éœ€è¦å°†é¡¹ç›®çš„ `Vue` ä¾èµ–æŒ‡å‘æœ¬åœ°æ„å»ºçš„ `Vue` æºç ã€‚é¦–å…ˆï¼Œåœ¨ä½ çš„ `Vue` é¡¹ç›®ä¸­åˆ é™¤ç°æœ‰çš„ `Vue` ä¾èµ–ï¼š

```bash
cd your-project-name
pnpm remove vue
```

ç„¶åä½¿ç”¨ `pnpm link` æ¥è¿æ¥æœ¬åœ°æ„å»ºçš„ `Vue`ï¼š

```bash
cd path/to/vue-next/packages/vue
pnpm link --global

cd path/to/your-project-name
pnpm link --global vue 
```

è¿™æ ·ä½ çš„é¡¹ç›®å°±ä¼šä½¿ç”¨æœ¬åœ°æ„å»ºçš„ `Vue` æºç äº†ã€‚

## å‚è€ƒèµ„æ–™

[esbuild ä¸­æ–‡æ–‡æ¡£](https://esbuild.bootcss.com/)
