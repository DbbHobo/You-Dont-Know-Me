## Vue3的template编译

目的是将用户写的`template`编译成渲染函数，渲染函数然后进一步解析为虚拟DOM。

`template -> AST -> AST+codegenNode -> 可执行code -> 渲染函数（render）-> VNode`

`Vue3` 提供了一个 `template` 在线编译成渲染函数的网站如下：
[Vue 3 Template Explorer](https://template-explorer.vuejs.org/#eyJzcmMiOiI8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+Iiwib3B0aW9ucyI6e319)

一个`AST`树的例子：
```js
{
    "type": 0,
    "children": [
        {
            "type": 1,
            "ns": 0,
            "tag": "div",
            "tagType": 0,
            "props": [
                {
                    "type": 6,
                    "name": "id",
                    "value": {
                        "type": 2,
                        "content": "example",
                        "loc": {
                            "start": {
                                "column": 9,
                                "line": 1,
                                "offset": 8
                            },
                            "end": {
                                "column": 18,
                                "line": 1,
                                "offset": 17
                            },
                            "source": "\"example\""
                        }
                    },
                    "loc": {
                        "start": {
                            "column": 6,
                            "line": 1,
                            "offset": 5
                        },
                        "end": {
                            "column": 18,
                            "line": 1,
                            "offset": 17
                        },
                        "source": "id=\"example\""
                    }
                }
            ],
            "isSelfClosing": false,
            "children": [
                {
                    "type": 2,
                    "content": "Hello World",
                    "loc": {
                        "start": {
                            "column": 19,
                            "line": 1,
                            "offset": 18
                        },
                        "end": {
                            "column": 30,
                            "line": 1,
                            "offset": 29
                        },
                        "source": "Hello World"
                    }
                }
            ],
            "loc": {
                "start": {
                    "column": 1,
                    "line": 1,
                    "offset": 0
                },
                "end": {
                    "column": 36,
                    "line": 1,
                    "offset": 35
                },
                "source": "<div id=\"example\">Hello World</div>"
            },
            "codegenNode": {
                "type": 13,
                "tag": "\"div\"",
                "props": {
                    "type": 15,
                    "loc": {
                        "start": {
                            "column": 1,
                            "line": 1,
                            "offset": 0
                        },
                        "end": {
                            "column": 36,
                            "line": 1,
                            "offset": 35
                        },
                        "source": "<div id=\"example\">Hello World</div>"
                    },
                    "properties": [
                        {
                            "type": 16,
                            "loc": {
                                "source": "",
                                "start": {
                                    "line": 1,
                                    "column": 1,
                                    "offset": 0
                                },
                                "end": {
                                    "line": 1,
                                    "column": 1,
                                    "offset": 0
                                }
                            },
                            "key": {
                                "type": 4,
                                "loc": {
                                    "source": "id",
                                    "start": {
                                        "column": 6,
                                        "line": 1,
                                        "offset": 5
                                    },
                                    "end": {
                                        "column": 8,
                                        "line": 1,
                                        "offset": 7
                                    }
                                },
                                "content": "id",
                                "isStatic": true,
                                "constType": 3
                            },
                            "value": {
                                "type": 4,
                                "loc": {
                                    "start": {
                                        "column": 9,
                                        "line": 1,
                                        "offset": 8
                                    },
                                    "end": {
                                        "column": 18,
                                        "line": 1,
                                        "offset": 17
                                    },
                                    "source": "\"example\""
                                },
                                "content": "example",
                                "isStatic": true,
                                "constType": 3
                            }
                        }
                    ]
                },
                "children": {
                    "type": 2,
                    "content": "Hello World",
                    "loc": {
                        "start": {
                            "column": 19,
                            "line": 1,
                            "offset": 18
                        },
                        "end": {
                            "column": 30,
                            "line": 1,
                            "offset": 29
                        },
                        "source": "Hello World"
                    }
                },
                "isBlock": true,
                "disableTracking": false,
                "isComponent": false,
                "loc": {
                    "start": {
                        "column": 1,
                        "line": 1,
                        "offset": 0
                    },
                    "end": {
                        "column": 36,
                        "line": 1,
                        "offset": 35
                    },
                    "source": "<div id=\"example\">Hello World</div>"
                }
            }
        }
    ],
    "helpers": {},
    "components": [],
    "directives": [],
    "hoists": [],
    "imports": [],
    "cached": 0,
    "temps": 0,
    "codegenNode": {
        "type": 13,
        "tag": "\"div\"",
        "props": {
            "type": 15,
            "loc": {
                "start": {
                    "column": 1,
                    "line": 1,
                    "offset": 0
                },
                "end": {
                    "column": 36,
                    "line": 1,
                    "offset": 35
                },
                "source": "<div id=\"example\">Hello World</div>"
            },
            "properties": [
                {
                    "type": 16,
                    "loc": {
                        "source": "",
                        "start": {
                            "line": 1,
                            "column": 1,
                            "offset": 0
                        },
                        "end": {
                            "line": 1,
                            "column": 1,
                            "offset": 0
                        }
                    },
                    "key": {
                        "type": 4,
                        "loc": {
                            "source": "id",
                            "start": {
                                "column": 6,
                                "line": 1,
                                "offset": 5
                            },
                            "end": {
                                "column": 8,
                                "line": 1,
                                "offset": 7
                            }
                        },
                        "content": "id",
                        "isStatic": true,
                        "constType": 3
                    },
                    "value": {
                        "type": 4,
                        "loc": {
                            "start": {
                                "column": 9,
                                "line": 1,
                                "offset": 8
                            },
                            "end": {
                                "column": 18,
                                "line": 1,
                                "offset": 17
                            },
                            "source": "\"example\""
                        },
                        "content": "example",
                        "isStatic": true,
                        "constType": 3
                    }
                }
            ]
        },
        "children": {
            "type": 2,
            "content": "Hello World",
            "loc": {
                "start": {
                    "column": 19,
                    "line": 1,
                    "offset": 18
                },
                "end": {
                    "column": 30,
                    "line": 1,
                    "offset": 29
                },
                "source": "Hello World"
            }
        },
        "isBlock": true,
        "disableTracking": false,
        "isComponent": false,
        "loc": {
            "start": {
                "column": 1,
                "line": 1,
                "offset": 0
            },
            "end": {
                "column": 36,
                "line": 1,
                "offset": 35
            },
            "source": "<div id=\"example\">Hello World</div>"
        }
    },
    "loc": {
        "start": {
            "column": 1,
            "line": 1,
            "offset": 0
        },
        "end": {
            "column": 36,
            "line": 1,
            "offset": 35
        },
        "source": "<div id=\"example\">Hello World</div>"
    },
    "filters": []
}
```
### 编译入口(浏览器端)
之前分析组件化的时候，第二个步骤调用`setupComponent`初始化组件中有这样一段，如果组件实例`instance`上没有`render`方法那就生成`render`方法：
```ts
// template / render function normalization
  // could be already set when returned from setup()
  if (!instance.render) {
    // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation
    // is done by server-renderer
    if (!isSSR && compile && !Component.render) {
      const template =
        (__COMPAT__ &&
          instance.vnode.props &&
          instance.vnode.props['inline-template']) ||
        Component.template ||
        resolveMergedOptions(instance).template
      if (template) {
        if (__DEV__) {
          startMeasure(instance, `compile`)
        }
        const { isCustomElement, compilerOptions } = instance.appContext.config
        const { delimiters, compilerOptions: componentCompilerOptions } =
          Component
        const finalCompilerOptions: CompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        )
        if (__COMPAT__) {
          // pass runtime compat config into the compiler
          finalCompilerOptions.compatConfig = Object.create(globalCompatConfig)
          if (Component.compatConfig) {
            // @ts-expect-error types are not compatible
            extend(finalCompilerOptions.compatConfig, Component.compatConfig)
          }
        }
        Component.render = compile(template, finalCompilerOptions)
        if (__DEV__) {
          endMeasure(instance, `compile`)
        }
      }
    }

    instance.render = (Component.render || NOOP) as InternalRenderFunction

    // for runtime-compiled render functions using `with` blocks, the render
    // proxy used needs a different `has` handler which is more performant and
    // also only allows a whitelist of globals to fallthrough.
    if (installWithProxy) {
      installWithProxy(instance)
    }
  }
```
其中一个关键的步骤，`compile`方法由`registerRuntimeCompiler`方法注册返回：
```ts
Component.render = compile(template, finalCompilerOptions)
instance.render = (Component.render || NOOP) as InternalRenderFunction

//【compile方法由registerRuntimeCompiler方法返回】
let compile: CompileFunction | undefined
let installWithProxy: (i: ComponentInternalInstance) => void

/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */
export function registerRuntimeCompiler(_compile: any) {
  compile = _compile
  installWithProxy = i => {
    if (i.render!._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers)
    }
  }
}
```
这个`compile`方法何时由`registerRuntimeCompiler`方法注册呢，可以看`packages/vue/src/index.ts`，可以看到是将`compileToFunction(template,options)`方法传入`registerRuntimeCompiler`方法。

从`@vue/compiler-dom`模块引入`compile`方法，在`compileToFunction`中调用DOM相关的`compile`得到的code通过`new Fuction(code)`转换成可执行的render函数：
```ts
//【编译过的template会进行缓存】
const compileCache: Record<string, RenderFunction> = Object.create(null)

function compileToFunction(
  template: string | HTMLElement,
  options?: CompilerOptions
): RenderFunction {
  //【template不是string则获取innerHTML内容】
  if (!isString(template)) {
    if (template.nodeType) {
      template = template.innerHTML
    } else {
      __DEV__ && warn(`invalid template option: `, template)
      return NOOP
    }
  }
  //【检查缓存看是否已经编译过】
  const key = template
  const cached = compileCache[key]
  if (cached) {
    return cached
  }
  //【template首字符是#当成DOM选择器获取DOM内容】
  if (template[0] === '#') {
    const el = document.querySelector(template)
    if (__DEV__ && !el) {
      warn(`Template element not found or is empty: ${template}`)
    }
    // __UNSAFE__
    // Reason: potential execution of JS expressions in in-DOM template.
    // The user must make sure the in-DOM template is trusted. If it's rendered
    // by the server, the template should not contain any user data.
    template = el ? el.innerHTML : ``
  }
  //【合并编译的选项】
  const opts = extend(
    {
      hoistStatic: true,
      onError: __DEV__ ? onError : undefined,
      onWarn: __DEV__ ? e => onError(e, true) : NOOP
    } as CompilerOptions,
    options
  )

  if (!opts.isCustomElement && typeof customElements !== 'undefined') {
    opts.isCustomElement = tag => !!customElements.get(tag)
  }

  //【通过compile方法获取code】
  const { code } = compile(template, opts)

  function onError(err: CompilerError, asWarning = false) {
    const message = asWarning
      ? err.message
      : `Template compilation error: ${err.message}`
    const codeFrame =
      err.loc &&
      generateCodeFrame(
        template as string,
        err.loc.start.offset,
        err.loc.end.offset
      )
    warn(codeFrame ? `${message}\n${codeFrame}` : message)
  }

  //【code生成render方法】
  // The wildcard import results in a huge object with every export
  // with keys that cannot be mangled, and can be quite heavy size-wise.
  // In the global build we know `Vue` is available globally so we can avoid
  // the wildcard object.
  const render = (
    __GLOBAL__ ? new Function(code)() : new Function('Vue', code)(runtimeDom)
  ) as RenderFunction

  // mark the function as runtime compiled
  ;(render as InternalRenderFunction)._rc = true

  //【编译完成后将render方法缓存下来并返回】
  return (compileCache[key] = render)
}
//【注册compile方法】
registerRuntimeCompiler(compileToFunction)
```
所以用户在实际生成render方法时最终调用的是`@vue/compiler-dom`模块引入的`compile`方法，`compileToFunction`是对`compile`方法的包裹，进行一些获取template实际内容、检查缓存、参数合并、code转为render函数、最终返回render函数等操作。

### compile
`compile` 方法输入是`template`和`options`，`template`是用户编写的模板代码，`options`是解析指令以及方法的函数选项，最终输出是一段可执行code，其中有三个关键步骤：
1. `parse`方法生成`AST`树
2. `transform`方法对`AST`树进行转换优化
3. `codeGen`方法生成可执行的代码
```ts
export function compile(
  template: string,
  options: CompilerOptions = {}
): CodegenResult {
  //【重载调用baseCompile】
  return baseCompile(
    template,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...(options.nodeTransforms || [])
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: __BROWSER__ ? null : stringifyStatic
    })
  )
}

export function baseCompile(
  template: string | RootNode,
  options: CompilerOptions = {}
): CodegenResult {
  const onError = options.onError || defaultOnError
  const isModuleMode = options.mode === 'module'
  /* istanbul ignore if */
  if (__BROWSER__) {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED))
    } else if (isModuleMode) {
      onError(createCompilerError(ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED))
    }
  }

  const prefixIdentifiers =
    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)
  if (!prefixIdentifiers && options.cacheHandlers) {
    onError(createCompilerError(ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED))
  }
  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED))
  }
  //【1-parse-template通过parse转化为ast树】
  const ast = isString(template) ? baseParse(template, options) : template  
  const [nodeTransforms, directiveTransforms] =
    getBaseTransformPreset(prefixIdentifiers)

  if (!__BROWSER__ && options.isTS) {
    const { expressionPlugins } = options
    if (!expressionPlugins || !expressionPlugins.includes('typescript')) {
      options.expressionPlugins = [...(expressionPlugins || []), 'typescript']
    }
  }

  //【2-transform-ast树经过transform优化】
  transform(
    ast,
    extend({}, options, {
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...(options.nodeTransforms || []) // user transforms
      ],
      directiveTransforms: extend(
        {},
        directiveTransforms,
        options.directiveTransforms || {} // user transforms
      )
    })
  )

  //【3-codeGen-generate方法生成code】
  return generate(
    ast,
    extend({}, options, {
      prefixIdentifiers
    })
  )
}
```
真正的`compile`方法在`packages/compiler-dom/src/index.ts`文件中，因为`compile`方法其实是平台相关的，我们分析的是在浏览器中。除此之外代码的组织还用到了函数柯理化的技巧，把基础的编译过程函数抽出来，通过 registerRuntimeCompiler(compileToFunction) 的方式把真正编译的过程和其它逻辑如对编译配置处理、缓存处理等剥离开，这样的设计还是非常巧妙的。：
```ts
export function compile(
  template: string,
  options: CompilerOptions = {}
): CodegenResult {
  return baseCompile(
    template,
    extend({}, parserOptions, options, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...(options.nodeTransforms || [])
      ],
      directiveTransforms: extend(
        {},
        DOMDirectiveTransforms,
        options.directiveTransforms || {}
      ),
      transformHoist: __BROWSER__ ? null : stringifyStatic
    })
  )
}
```

### parse
- `parse` 主要是将 `template` 转成 `AST`。`AST`是一种抽象语法树，是对源代码的抽象语法结构的树状表现形式，最终的`AST`树应该是以这样数据结构的对象嵌套。
```ts
{
  type: 0,
  children,
  helpers: [],
  components: [],
  directives: [],
  hoists: [],
  imports: [],
  cached: 0,
  temps: 0,
  codegenNode: undefined,
  loc
}
```

首先调用`baseParse`如下，`extend({}, parserOptions, options)` 将 `parserOptions` 和 `options` 合并，`export const extend = Object.assign`，`extend`其实就是`Object.assign`方法，`parserOptions` 是平台相关的解析选项，`options` 则是用户可选择的解析选项：：
```ts
export function parse(template: string, options: ParserOptions = {}): RootNode {
  return baseParse(template, extend({}, parserOptions, options))
}

export function baseParse(
  content: string,
  options: ParserOptions = {}
): RootNode {
  const context = createParserContext(content, options)
  const start = getCursor(context)
  return createRoot(
    parseChildren(context, TextModes.DATA, []),//【解析子节点】
    getSelection(context, start)//【获取起始终点位置，第几行第几列】
  )
}

export function createRoot(
  children: TemplateChildNode[],
  loc = locStub
): RootNode {
  return {
    type: NodeTypes.ROOT,
    children,
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: undefined,
    loc
  }
}

function getSelection(
  context: ParserContext,
  start: Position,
  end?: Position
): SourceLocation {
  end = end || getCursor(context)
  return {
    start,
    end,
    source: context.originalSource.slice(start.offset, end.offset)
  }
}
```

然后继续看`parseChildren`方法，递归解析子节点，其实也就是解析字符串：
- 遍历`context.source`也就是源代码
- 如果以 '\{\{' 开始，当成插值解析
- 如果以 '<' 开始，'<'根据后面跟的内容又分为几种类型，例如如果是字母说明是标签也就是调用`parseElement`方法解析，如果能正确的解析出来都会调用`advanceBy`方法“吃掉”已解析的字符串
- 处理空白
- 最终返回解析结果
```ts
export const enum TextModes {
  //          | Elements | Entities | End sign              | Inside of
  DATA, //    | ✔        | ✔        | End tags of ancestors |
  RCDATA, //  | ✘        | ✔        | End tag of the parent | <textarea>
  RAWTEXT, // | ✘        | ✘        | End tag of the parent | <style>,<script>
  CDATA,
  ATTRIBUTE_VALUE
}
//【编译出错调用此方法】
function emitError(
  context: ParserContext,
  code: ErrorCodes,
  offset?: number,
  loc: Position = getCursor(context)
): void {
  if (offset) {
    loc.offset += offset
    loc.column += offset
  }
  context.options.onError(
    createCompilerError(code, {
      start: loc,
      end: loc,
      source: ''
    })
  )
}

function parseChildren(
  context: ParserContext,
  mode: TextModes,
  ancestors: ElementNode[]
): TemplateChildNode[] {
  const parent = last(ancestors)
  const ns = parent ? parent.ns : Namespaces.HTML
  const nodes: TemplateChildNode[] = []

  while (!isEnd(context, mode, ancestors)) {
    __TEST__ && assert(context.source.length > 0)
    const s = context.source
    let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined

    if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
        //【s[0]是{{】
        // '{{'
        node = parseInterpolation(context, mode)
      } else if (mode === TextModes.DATA && s[0] === '<') {
        //【s[0]是'<'，s[1]后又走向'!'、'/'、/[a-z]/i.test(s[1])、'?'几个可能分支】
        // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
        if (s.length === 1) {
          emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)
        } else if (s[1] === '!') {
          // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
          if (startsWith(s, '<!--')) {
            node = parseComment(context)
          } else if (startsWith(s, '<!DOCTYPE')) {
            // Ignore DOCTYPE by a limitation.
            node = parseBogusComment(context)
          } else if (startsWith(s, '<![CDATA[')) {
            if (ns !== Namespaces.HTML) {
              node = parseCDATA(context, ancestors)
            } else {
              emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT)
              node = parseBogusComment(context)
            }
          } else {
            emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT)
            node = parseBogusComment(context)
          }
        } else if (s[1] === '/') {
          // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
          if (s.length === 2) {
            emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2)
          } else if (s[2] === '>') {
            emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2)
            advanceBy(context, 3)
            continue
          } else if (/[a-z]/i.test(s[2])) {
            emitError(context, ErrorCodes.X_INVALID_END_TAG)
            parseTag(context, TagType.End, parent)
            continue
          } else {
            emitError(
              context,
              ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME,
              2
            )
            node = parseBogusComment(context)
          }
        } else if (/[a-z]/i.test(s[1])) {
          node = parseElement(context, ancestors)

          // 2.x <template> with no directive compat
          if (
            __COMPAT__ &&
            isCompatEnabled(
              CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE,
              context
            ) &&
            node &&
            node.tag === 'template' &&
            !node.props.some(
              p =>
                p.type === NodeTypes.DIRECTIVE &&
                isSpecialTemplateDirective(p.name)
            )
          ) {
            __DEV__ &&
              warnDeprecation(
                CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE,
                context,
                node.loc
              )
            node = node.children
          }
        } else if (s[1] === '?') {
          emitError(
            context,
            ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,
            1
          )
          node = parseBogusComment(context)
        } else {
          emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)
        }
      }
    }
    if (!node) {
      node = parseText(context, mode)
    }

    if (isArray(node)) {
      for (let i = 0; i < node.length; i++) {
        pushNode(nodes, node[i])
      }
    } else {
      pushNode(nodes, node)
    }
  }

  // Whitespace handling strategy like v2
  let removedWhitespace = false
  if (mode !== TextModes.RAWTEXT && mode !== TextModes.RCDATA) {
    const shouldCondense = context.options.whitespace !== 'preserve'
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i]
      if (node.type === NodeTypes.TEXT) {
        if (!context.inPre) {
          if (!/[^\t\r\n\f ]/.test(node.content)) {
            const prev = nodes[i - 1]
            const next = nodes[i + 1]
            // Remove if:
            // - the whitespace is the first or last node, or:
            // - (condense mode) the whitespace is adjacent to a comment, or:
            // - (condense mode) the whitespace is between two elements AND contains newline
            if (
              !prev ||
              !next ||
              (shouldCondense &&
                (prev.type === NodeTypes.COMMENT ||
                  next.type === NodeTypes.COMMENT ||
                  (prev.type === NodeTypes.ELEMENT &&
                    next.type === NodeTypes.ELEMENT &&
                    /[\r\n]/.test(node.content))))
            ) {
              removedWhitespace = true
              nodes[i] = null as any
            } else {
              // Otherwise, the whitespace is condensed into a single space
              node.content = ' '
            }
          } else if (shouldCondense) {
            // in condense mode, consecutive whitespaces in text are condensed
            // down to a single space.
            node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ')
          }
        } else {
          // #6410 normalize windows newlines in <pre>:
          // in SSR, browsers normalize server-rendered \r\n into a single \n
          // in the DOM
          node.content = node.content.replace(/\r\n/g, '\n')
        }
      }
      // Remove comment nodes if desired by configuration.
      else if (node.type === NodeTypes.COMMENT && !context.options.comments) {
        removedWhitespace = true
        nodes[i] = null as any
      }
    }
    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
      // remove leading newline per html spec
      // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
      const first = nodes[0]
      if (first && first.type === NodeTypes.TEXT) {
        first.content = first.content.replace(/^\r?\n/, '')
      }
    }
  }

  return removedWhitespace ? nodes.filter(Boolean) : nodes
}
```

在解析`template`的时候，把`template`当成字符串，逐步解析，可以看到`advanceBy`函数，将解析完的部分逐渐从`template`字符串中剥离。然后根据正则匹配，不同的类型节点进行不同方法的处理，最终返回一个完整的AST树，所谓的不同类型有如下等：
  - 元素节点
  - 属性节点
  - 指令节点
  - 文本节点
  - 差值节点
  - 注释节点

下面看一个具体`template`例子，比如最简单的编译注释，是如何处理的：
```js
export const enum NodeTypes {
  ROOT,
  ELEMENT,
  TEXT,
  COMMENT,
  SIMPLE_EXPRESSION,
  INTERPOLATION,
  ATTRIBUTE,
  DIRECTIVE,
  // containers
  COMPOUND_EXPRESSION,
  IF,
  IF_BRANCH,
  FOR,
  TEXT_CALL,
  // codegen
  VNODE_CALL,
  JS_CALL_EXPRESSION,
  JS_OBJECT_EXPRESSION,
  JS_PROPERTY,
  JS_ARRAY_EXPRESSION,
  JS_FUNCTION_EXPRESSION,
  JS_CONDITIONAL_EXPRESSION,
  JS_CACHE_EXPRESSION,

  // ssr codegen
  JS_BLOCK_STATEMENT,
  JS_TEMPLATE_LITERAL,
  JS_IF_STATEMENT,
  JS_ASSIGNMENT_EXPRESSION,
  JS_SEQUENCE_EXPRESSION,
  JS_RETURN_STATEMENT
}

function parseComment(context: ParserContext): CommentNode {
  __TEST__ && assert(startsWith(context.source, '<!--'))

  const start = getCursor(context)
  let content: string

  // Regular comment.
  const match = /--(\!)?>/.exec(context.source)
  if (!match) {
    content = context.source.slice(4)
    advanceBy(context, context.source.length)
    emitError(context, ErrorCodes.EOF_IN_COMMENT)
  } else {
    if (match.index <= 3) {
      emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT)
    }
    if (match[1]) {
      emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT)
    }
    content = context.source.slice(4, match.index)

    // Advancing with reporting nested comments.
    const s = context.source.slice(0, match.index)
    let prevIndex = 1,
      nestedIndex = 0
    while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1)
      if (nestedIndex + 4 < s.length) {
        emitError(context, ErrorCodes.NESTED_COMMENT)
      }
      prevIndex = nestedIndex + 1
    }
    advanceBy(context, match.index + match[0].length - prevIndex + 1)
  }

  return {
    type: NodeTypes.COMMENT,
    content,
    loc: getSelection(context, start)
  }
}
```
可以看到最后返回了一个对象，`type`是`NodeTypes.COMMENT`也就是枚举类型的值3，`content`具体内容以及`loc`也就是该内容的位置。下面用官方的在线编译网站编译了`<!-- 我是一条注释 -->`这样一段注释：
```js
{
    "type": 3,
    "content": " 我是一条注释 ",
    "loc": {
        "start": {
            "column": 1,
            "line": 2,
            "offset": 23
        },
        "end": {
            "column": 16,
            "line": 2,
            "offset": 38
        },
        "source": "<!-- 我是一条注释 -->"
    }
}
```
还有例如解析属性的时候，对于Vue的指定，判断正则如下：
```js
const match =
      /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
        name
      )!
```

### transform
<!-- TODO -->
- `transform` 主要通过`transform`方法将 `AST` 进行优化转换，并确定`patchFlag`。
```js
export function transform(root: RootNode, options: TransformOptions) {
  const context = createTransformContext(root, options)
  //【深度遍历】
  traverseNode(root, context)
  //【静态提升】
  if (options.hoistStatic) {
    hoistStatic(root, context)
  }
  if (!options.ssr) {
    createRootCodegen(root, context)
  }
  // finalize meta information
  root.helpers = [...context.helpers.keys()]
  root.components = [...context.components]
  root.directives = [...context.directives]
  root.imports = context.imports
  root.hoists = context.hoists
  root.temps = context.temps
  root.cached = context.cached

  if (__COMPAT__) {
    root.filters = [...context.filters!]
  }
}


export function traverseNode(
  node: RootNode | TemplateChildNode,
  context: TransformContext
) {
  context.currentNode = node
  // apply transform plugins
  const { nodeTransforms } = context
  const exitFns = []
  for (let i = 0; i < nodeTransforms.length; i++) {
    const onExit = nodeTransforms[i](node, context)
    if (onExit) {
      if (isArray(onExit)) {
        exitFns.push(...onExit)
      } else {
        exitFns.push(onExit)
      }
    }
    if (!context.currentNode) {
      // node was removed
      return
    } else {
      // node may have been replaced
      node = context.currentNode
    }
  }
  // 根据节点类型进行不同的操作
  switch (node.type) {
    case NodeTypes.COMMENT:
      if (!context.ssr) {
        // inject import for the Comment symbol, which is needed for creating
        // comment nodes with `createVNode`
        context.helper(CREATE_COMMENT)
      }
      break
    case NodeTypes.INTERPOLATION:
      // no need to traverse, but we need to inject toString helper
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING)
      }
      break

    // for container types, further traverse downwards
    case NodeTypes.IF:
      for (let i = 0; i < node.branches.length; i++) {
        traverseNode(node.branches[i], context)
      }
      break
    case NodeTypes.IF_BRANCH:
    case NodeTypes.FOR:
    case NodeTypes.ELEMENT:
    case NodeTypes.ROOT:
      traverseChildren(node, context)
      break
  }

  // exit transforms
  context.currentNode = node
  let i = exitFns.length
  while (i--) {
    exitFns[i]()
  }
}
```
可以看到对不同类型节点进行不同处理，例如对注释节点的处理如下：
```js
case NodeTypes.COMMENT:
  if (!context.ssr) {
    // inject import for the Comment symbol, which is needed for creating
    // comment nodes with `createVNode`
    context.helper(CREATE_COMMENT)
  }
  break

export const CREATE_COMMENT = Symbol(__DEV__ ? `createCommentVNode` : ``)
```
一个经过编译后的注释例子`<!-- 我是注释 -->`的ast和code如下：
```js
{
    "type": 0,
    "children": [
        {
            "type": 3,
            "content": " 我是注释 ",
            "loc": {
                "start": {
                    "column": 1,
                    "line": 1,
                    "offset": 0
                },
                "end": {
                    "column": 14,
                    "line": 1,
                    "offset": 13
                },
                "source": "<!-- 我是注释 -->"
            }
        }
    ],
    "helpers": {},
    "components": [],
    "directives": [],
    "hoists": [],
    "imports": [],
    "cached": 0,
    "temps": 0,
    "codegenNode": {
        "type": 3,
        "content": " 我是注释 ",
        "loc": {
            "start": {
                "column": 1,
                "line": 1,
                "offset": 0
            },
            "end": {
                "column": 14,
                "line": 1,
                "offset": 13
            },
            "source": "<!-- 我是注释 -->"
        }
    },
    "loc": {
        "start": {
            "column": 1,
            "line": 1,
            "offset": 0
        },
        "end": {
            "column": 14,
            "line": 1,
            "offset": 13
        },
        "source": "<!-- 我是注释 -->"
    },
    "filters": []
}


import { createCommentVNode as _createCommentVNode } from "vue"

export function render(_ctx, _cache, $props, $setup, $data, $options) {
  return _createCommentVNode(" 我是注释 ")
}
```

### codegen
- `codegen` 主要是通过`generate`方法将 `AST` 树转换成可执行的代码也就是在运行时执行的代码的字符串。
```js
export function generate(
  ast: RootNode,
  options: CodegenOptions & {
    onContextCreated?: (context: CodegenContext) => void
  } = {}
): CodegenResult {
  const context = createCodegenContext(ast, options)
  if (options.onContextCreated) options.onContextCreated(context)
  const {
    mode,
    push,
    prefixIdentifiers,
    indent,
    deindent,
    newline,
    scopeId,
    ssr
  } = context

  const hasHelpers = ast.helpers.length > 0
  const useWithBlock = !prefixIdentifiers && mode !== 'module'
  const genScopeId = !__BROWSER__ && scopeId != null && mode === 'module'
  const isSetupInlined = !__BROWSER__ && !!options.inline

  // preambles
  // in setup() inline mode, the preamble is generated in a sub context
  // and returned separately.
  const preambleContext = isSetupInlined
    ? createCodegenContext(ast, options)
    : context
  if (!__BROWSER__ && mode === 'module') {
    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)
  } else {
    genFunctionPreamble(ast, preambleContext)
  }
  // enter render function
  const functionName = ssr ? `ssrRender` : `render`
  const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']
  if (!__BROWSER__ && options.bindingMetadata && !options.inline) {
    // binding optimization args
    args.push('$props', '$setup', '$data', '$options')
  }
  const signature =
    !__BROWSER__ && options.isTS
      ? args.map(arg => `${arg}: any`).join(',')
      : args.join(', ')
  // 代码开头，根据是否inline，写成箭头函数或者function xxx
  if (isSetupInlined) {
    push(`(${signature}) => {`)
  } else {
    push(`function ${functionName}(${signature}) {`)
  }
  indent()

  if (useWithBlock) {
    push(`with (_ctx) {`)
    indent()
    // function mode const declarations should be inside with block
    // also they should be renamed to avoid collision with user properties
    if (hasHelpers) {
      push(`const { ${ast.helpers.map(aliasHelper).join(', ')} } = _Vue`)
      push(`\n`)
      newline()
    }
  }

  // generate asset resolution statements
  if (ast.components.length) {
    genAssets(ast.components, 'component', context)
    if (ast.directives.length || ast.temps > 0) {
      newline()
    }
  }
  if (ast.directives.length) {
    genAssets(ast.directives, 'directive', context)
    if (ast.temps > 0) {
      newline()
    }
  }
  if (__COMPAT__ && ast.filters && ast.filters.length) {
    newline()
    genAssets(ast.filters, 'filter', context)
    newline()
  }

  if (ast.temps > 0) {
    push(`let `)
    for (let i = 0; i < ast.temps; i++) {
      push(`${i > 0 ? `, ` : ``}_temp${i}`)
    }
  }
  if (ast.components.length || ast.directives.length || ast.temps) {
    push(`\n`)
    newline()
  }

  // generate the VNode tree expression
  if (!ssr) {
    push(`return `)
  }
  if (ast.codegenNode) {
    genNode(ast.codegenNode, context)
  } else {
    push(`null`)
  }

  if (useWithBlock) {
    deindent()
    push(`}`)
  }

  deindent()
  push(`}`)

  return {
    ast,
    code: context.code,
    preamble: isSetupInlined ? preambleContext.code : ``,
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: context.map ? (context.map as any).toJSON() : undefined
  }
}


function genAssets(
  assets: string[],
  type: 'component' | 'directive' | 'filter',
  { helper, push, newline, isTS }: CodegenContext
) {
  const resolver = helper(
    __COMPAT__ && type === 'filter'
      ? RESOLVE_FILTER
      : type === 'component'
      ? RESOLVE_COMPONENT
      : RESOLVE_DIRECTIVE
  )
  for (let i = 0; i < assets.length; i++) {
    let id = assets[i]
    // potential component implicit self-reference inferred from SFC filename
    const maybeSelfReference = id.endsWith('__self')
    if (maybeSelfReference) {
      id = id.slice(0, -6)
    }
    push(
      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${
        maybeSelfReference ? `, true` : ``
      })${isTS ? `!` : ``}`
    )
    if (i < assets.length - 1) {
      newline()
    }
  }
}
```
例如`v-for`指令解析时，我们要用到`runtime`时的方法`renderList`循环遍历生成内容，列举如下：
```js
export const helperNameMap: Record<symbol, string> = {
  [FRAGMENT]: `Fragment`,
  [TELEPORT]: `Teleport`,
  [SUSPENSE]: `Suspense`,
  [KEEP_ALIVE]: `KeepAlive`,
  [BASE_TRANSITION]: `BaseTransition`,
  [OPEN_BLOCK]: `openBlock`,
  [CREATE_BLOCK]: `createBlock`,
  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
  [CREATE_VNODE]: `createVNode`,
  [CREATE_ELEMENT_VNODE]: `createElementVNode`,
  [CREATE_COMMENT]: `createCommentVNode`,
  [CREATE_TEXT]: `createTextVNode`,
  [CREATE_STATIC]: `createStaticVNode`,
  [RESOLVE_COMPONENT]: `resolveComponent`,
  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
  [RESOLVE_DIRECTIVE]: `resolveDirective`,
  [RESOLVE_FILTER]: `resolveFilter`,
  [WITH_DIRECTIVES]: `withDirectives`,
  [RENDER_LIST]: `renderList`,
  [RENDER_SLOT]: `renderSlot`,
  [CREATE_SLOTS]: `createSlots`,
  [TO_DISPLAY_STRING]: `toDisplayString`,
  [MERGE_PROPS]: `mergeProps`,
  [NORMALIZE_CLASS]: `normalizeClass`,
  [NORMALIZE_STYLE]: `normalizeStyle`,
  [NORMALIZE_PROPS]: `normalizeProps`,
  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
  [TO_HANDLERS]: `toHandlers`,
  [CAMELIZE]: `camelize`,
  [CAPITALIZE]: `capitalize`,
  [TO_HANDLER_KEY]: `toHandlerKey`,
  [SET_BLOCK_TRACKING]: `setBlockTracking`,
  [PUSH_SCOPE_ID]: `pushScopeId`,
  [POP_SCOPE_ID]: `popScopeId`,
  [WITH_CTX]: `withCtx`,
  [UNREF]: `unref`,
  [IS_REF]: `isRef`,
  [WITH_MEMO]: `withMemo`,
  [IS_MEMO_SAME]: `isMemoSame`
}
```

### 编译实例
实际的例子：
```js
<script src="../../dist/vue.global.js"></script>

<div id="demo">
  <div v-for="{ commit, url } in commits">
    <span :id="commit.author">{{ commit.author.date }}</span>
    ---
    <span @click="handleClick()">{{ url }}</span>
  </div>
</div>

<script>
const { ref,watchEffect } = Vue
const API_URL = `https://api.github.com/repos/vuejs/core/commits?per_page=2&sha=`

Vue.createApp({
  setup() {
    const currentBranch = ref('')
    const commits = ref(null)

    watchEffect(() => {
      fetch(`${API_URL}${currentBranch.value}`)
        .then(res => res.json())
        .then(data => {
          commits.value = data
        })
    })
    // currentBranch.value = 'main'
    handleClick = (e) => {
      console.log('its click',e)
    }
    return {
      commits
    }
  }
}).mount('#demo')
</script>
```

可以看到编译出的code，可以看到需要`patch`的几个地方都有对应的`patchFlag`，在后续`patch`过程中是非常重要的优化前置条件，还有绑定的事件会进行缓存，不会每次重新声明一个函数引起子组件更新等问题：
```ts
const _Vue = Vue
const { createElementVNode: _createElementVNode, createTextVNode: _createTextVNode } = _Vue

const _hoisted_1 = ["id"]
const _hoisted_2 = ["onClick"]

return function render(_ctx, _cache) {
  with (_ctx) {
    const { renderList: _renderList, Fragment: _Fragment, openBlock: _openBlock, createElementBlock: _createElementBlock, toDisplayString: _toDisplayString, createElementVNode: _createElementVNode, createTextVNode: _createTextVNode } = _Vue

    return (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(commits, ({ commit, url }) => {
      return (_openBlock(), _createElementBlock("div", null, [
        _createElementVNode("span", { id: commit.author }, _toDisplayString(commit.author.date), 9 /* TEXT, PROPS */, _hoisted_1),
        _createTextVNode(" --- "),
        _createElementVNode("span", {
          onClick: $event => (handleClick())
        }, _toDisplayString(url), 9 /* TEXT, PROPS */, _hoisted_2)
      ]))
    }), 256 /* UNKEYED_FRAGMENT */))
  }
}
```