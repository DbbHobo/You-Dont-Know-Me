# 文件传输

## 服务器端到客户端传输文件

### 开启gzip压缩

```js
const fs = require("fs");
const zlib = require("zlib");
const http = require("http");
const util = require("util");
const readFile = util.promisify(fs.readFile);
const gzip = util.promisify(zlib.gzip);

const server = http.createServer(async (req, res) => {
  res.writeHead(200, {
    "Content-Type": "text/plain;charset=utf-8",
    "Content-Encoding": "gzip"
  });
  const buffer = await readFile(__dirname + "/big-file.txt");
  const gzipData = await gzip(buffer);
  res.write(gzipData);
  res.end();
});

server.listen(3000, () => {
  console.log("app starting at port 3000");
});
```

### 分块传输/流式传输

```js

const fs = require("fs");
const http = require("http");

const buffer = fs.readFileSync(__dirname + "/big-file.txt");
const lines = buffer.toString("utf-8").split("\n");
const chunks = chunk(lines, 10);

// 给文件分块
function chunk(arr, len) {
  let chunks = [],
      i = 0,
      n = arr.length;
  while (i < n) {
    chunks.push(arr.slice(i, (i += len)));
  }
  return chunks;
}

// 分块传输
http
  .createServer(async function (req, res) {
    res.writeHead(200, {
      "Content-Type": "text/plain;charset=utf-8",
      "Transfer-Encoding": "chunked",
      "Access-Control-Allow-Origin": "*",
    });
    for (let index = 0; index < chunks.length; index++) {
      setTimeout(() => {
        let content = chunks[index].join("&");
        res.write(`${content.length.toString(16)}\r\n${content}\r\n`);
      },200);
    }
    setTimeout(() => {
      res.end();
    }, chunks.length * 1000);
  })
  .listen(3000, () => {
    console.log("app starting at port 3000");
  });

```

```js
// 流式传输
const fs = require("fs");
const zlib = require("zlib");
const http = require("http");

http
  .createServer((req, res) => {
    res.writeHead(200, {
      "Content-Type": "text/plain;charset=utf-8",
      "Content-Encoding": "gzip",
    });
    fs.createReadStream(__dirname + "/big-file.txt")
      .setEncoding("utf-8")
      .pipe(zlib.createGzip())
      .pipe(res);
  })
  .listen(3000, () => {
    console.log("app starting at port 3000");
  });
```

### 范围请求

```js
const msgList = document.querySelector("#msgList");
function getBinaryContent(url, start, end, responseType = "arraybuffer") {
  return new Promise((resolve, reject) => {
    try {
      let xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);
      xhr.setRequestHeader("range", `bytes=${start}-${end}`);
      xhr.responseType = responseType;
      xhr.onload = function () {
        resolve(xhr.response);
      };
      xhr.send();
    } catch (err) {
      reject(new Error(err));
    }
  });
}

getBinaryContent(
  "http://localhost:3000/big-file.txt",
  0, 100, "text"
).then((text) => {
  msgList.append(`${text}`);
});
```

## web端文件上传相关API

### Blob()

`Blob`（Binary Large Object）表示二进制类型的大对象。`Blob` 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 `ReadableStream` 来用于数据操作。

`Blob` 表示的不一定是 `JavaScript` 原生格式的数据。`File` 接口基于 `Blob`，继承了 `blob` 的功能并将其扩展以支持用户系统上的文件。

实例属性：

- `Blob.prototype.size`

`Blob` 对象中所包含数据的大小（字节）。

- `Blob.prototype.type`

一个字符串，表明该 `Blob` 对象所包含数据的 `MIME` 类型。如果类型未知，则该值为空字符串。

实例方法：

- `Blob.prototype.arrayBuffer()`

返回一个 `promise`，其会兑现一个包含 `Blob` 所有内容的二进制格式的 `ArrayBuffer`。

- `Blob.prototype.slice()`

返回一个新的 `Blob` 对象，包含了源 `Blob` 对象中指定范围内的数据。

- `Blob.prototype.stream()`

返回一个能读取 `Blob` 内容的 `ReadableStream`。

- `Blob.prototype.text()`

返回一个 `promise`，其会兑现一个包含 `Blob` 所有内容的 UTF-8 格式的字符串。

### File()

通常情况下， `File` 对象是来自用户在一个 `<input>` 元素上选择文件后返回的 `FileList` 对象，也可以是来拖拽操作生成的 `DataTransfer` 对象，或者来自 `HTMLCanvasElement` 上的 `mozGetAsFile()` API。

`File` 对象是特殊类型的 `Blob`，且可以用在任意的 `Blob` 类型的 `context` 中。比如说， `FileReader`, `URL.createObjectURL()`, `createImageBitmap()`, 及 `XMLHttpRequest.send()` 都能处理 `Blob` 和 `File`。

`File` 接口也继承了 `Blob` 接口的属性：

- `File.lastModified` 只读
返回当前 File 对象所引用文件最后修改时间，自 UNIX 时间起始值（1970 年 1 月 1 日 00:00:00 UTC）以来的毫秒数。

- `File.name` 只读
返回当前 File 对象所引用文件的名字。

- `File.size` 只读
返回文件的大小。

- `File.webkitRelativePath` 只读 非标准
返回 File 相关的 path 或 URL。

- `File.type` 只读
返回文件的 多用途互联网邮件扩展类型（MIME Type）

### ArrayBuffer()

`ArrayBuffer`对象、`TypedArray`视图和`DataView`视图是 `JavaScript` 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。

`ArrayBuffer`对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（`TypedArray`视图和DataView视图）来读写，视图的作用是以指定格式解读二进制数据。

`ArrayBuffer`也是一个构造函数，可以分配一段可以存放数据的**连续内存区域**。

```js
const buf = new ArrayBuffer(32);
```

上面代码生成了一段 32 字节的内存区域，每个字节的值默认都是 0。可以看到，`ArrayBuffer`构造函数的参数是所需要的内存大小（单位字节）。

- `ArrayBuffer.prototype.byteLength`

`ArrayBuffer`实例的`byteLength`属性，返回所分配的内存区域的字节长度。

```js
const buffer = new ArrayBuffer(32);
buffer.byteLength
// 32
```

如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。

```js
if (buffer.byteLength === n) {
  // 成功
} else {
  // 失败
}
```

- `ArrayBuffer.prototype.slice()`

`ArrayBuffer`实例有一个`slice`方法，允许将内存区域的一部分，拷贝生成一个新的`ArrayBuffer`对象。

```js
const buffer = new ArrayBuffer(8);
const newBuffer = buffer.slice(0, 3);
```

上面代码拷贝buffer对象的前 3 个字节（从 0 开始，到第 3 个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。

`slice`方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原`ArrayBuffer`对象的结尾。

除了`slice`方法，`ArrayBuffer`对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。

- `ArrayBuffer.isView()`

`ArrayBuffer`有一个静态方法`isView`，返回一个布尔值，表示参数是否为`ArrayBuffer`的视图实例。这个方法大致相当于判断参数，是否为`TypedArray`实例或`DataView`实例。

```js
const buffer = new ArrayBuffer(8);
ArrayBuffer.isView(buffer) // false
const v = new Int32Array(buffer);
ArrayBuffer.isView(v) // true
```

### Formdata()

`FormData` 接口提供了一种表示表单数据的键值对 `key/value` 的构造方式，并且可以轻松的将数据通过 `XMLHttpRequest.send()` 方法发送出去，本接口和此方法都相当简单直接。如果送出时的编码类型被设为 `multipart/form-data`，它会使用和表单一样的格式。

如果你想构建一个简单的GET请求，并且通过`<form>`的形式带有查询参数，可以将它直接传递给 `URLSearchParams`。

实现了 `FormData` 接口的对象可以直接在 `for...of` 结构中使用，而不需要调用 `entries() : for (var p of myFormData)` 的作用和 `for (var p of myFormData.entries())` 是相同的。

静态方法：

- `FormData.append()`

向 `FormData` 中添加新的属性值，`FormData` 对应的属性值存在也不会覆盖原值，而是新增一个值，如果属性不存在则新增一项属性值。

- `FormData.delete()`

从 `FormData` 对象里面删除一个键值对。

- `FormData.entries()`

返回一个包含所有键值对的`iterator`对象。

- `FormData.get()`

返回在 `FormData` 对象中与给定键关联的第一个值。

- `FormData.getAll()`

返回一个包含 `FormData` 对象中与给定键关联的所有值的数组。

- `FormData.has()`

返回一个布尔值表明 `FormData` 对象是否包含某些键。

- `FormData.keys()`

返回一个包含所有键的`iterator`对象。

- `FormData.set()`

给 `FormData` 设置属性值，如果 `FormData` 对应的属性值存在则覆盖原值，否则新增一项属性值。

- `FormData.values()`

返回一个包含所有值的`iterator`对象。

### FileReader()

`FileReader` 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 `File` 或 `Blob` 对象指定要读取的文件或数据。

其中 `File` 对象可以是来自用户在一个`<input>`元素上选择文件后返回的`FileList`对象，也可以来自拖放操作生成的`DataTransfer`对象，还可以是来自在一个`HTMLCanvasElement`上执行`mozGetAsFile()`方法后返回结果。

实例属性：

- `FileReader.error` 只读

一个DOMException，表示在读取文件时发生的错误。

- `FileReader.readyState` 只读

表示FileReader状态的数字。取值如下：

`EMPTY 0`还没有加载任何数据。
`LOADING 1`数据正在被加载。
`DONE 2`已完成全部的读取请求。

- `FileReader.result` 只读

文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。

静态方法：

- `FileReader.onabort`

处理abort事件。该事件在读取操作被中断时触发。

- `FileReader.onerror`

处理error事件。该事件在读取操作发生错误时触发。

- `FileReader.onload`

处理load事件。该事件在读取操作完成时触发。

- `FileReader.onloadstart`

处理loadstart事件。该事件在读取操作开始时触发。

- `FileReader.onloadend`

处理loadend事件。该事件在读取操作结束时（要么成功，要么失败）触发。

- `FileReader.onprogress`

处理progress事件。该事件在读取Blob时触发。

备注： 因为 FileReader 继承自EventTarget，所以所有这些事件也可以通过addEventListener方法使用。

- `FileReader.abort()`

中止读取操作。在返回时，readyState属性为DONE。

- `FileReader.readAsArrayBuffer()`

开始读取指定的 Blob 中的内容，一旦完成，result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象。

- `FileReader.readAsBinaryString()` 非标准

开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。

- `FileReader.readAsDataURL()`

开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL 格式的 Base64 字符串以表示所读取文件的内容。

- `FileReader.readAsText()`

开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。

### DataTransfer()

### navigator.Clipboard()

## web端到服务器端传输文件

常用的文件上传解决方案：

- 单文件上传：利用 `input` 元素的 `accept` 属性限制上传文件的类型、利用 JS 检测文件的类型及使用 Koa 实现单文件上传的功能；
- 多文件上传：利用 `input` 元素的 `multiple` 属性支持选择多文件及使用 Koa 实现多文件上传的功能；
- 目录上传：利用 `input` 元素上的 `webkitdirectory` 属性支持目录上传的功能及使用 Koa 实现目录上传并按文件目录结构存放的功能；
- 压缩目录上传：在目录上传的基础上，利用 `JSZip` 实现压缩目录上传的功能；
- 拖拽上传：利用拖拽事件和 `DataTransfer` 对象实现拖拽上传的功能；
- 剪贴板上传：利用剪贴板事件和 `Clipboard API` 实现剪贴板上传的功能；
- 服务端上传：利用第三方库 `form-data` 实现服务端文件流式上传的功能；

```js
<input id="uploadFile" type="file" accept="image/*" multiple />
<input id="uploadFile" type="file" accept="image/*" multiple />
```

## web端大文件上传

## 文件下载

- 使用 `<a>` 标签：

最简单的方法是创建一个带有 download 属性的 `<a>` 标签，将文件的 `URL` 设置为 `href` 属性，然后通过点击这个链接来触发下载。这适用于直接下载链接的情况。

```html
<a href="文件的URL" download="自定义文件名">点击下载文件</a>
```

这种方法对于简单的文件下载非常方便，但在处理需要动态生成文件内容的情况下可能不太适用。

- 使用 `Blob`：

如果你需要在前端动态生成文件内容，可以使用 JavaScript 创建一个 `Blob`（二进制大对象），然后将其转换为可下载的链接。

```js
const content = '文件的内容';
const blob = new Blob([content], { type: 'mime/type' }); // 替换为实际的 MIME 类型
const url = URL.createObjectURL(blob);

const downloadLink = document.createElement('a');
downloadLink.href = url;
downloadLink.download = '文件名';
downloadLink.innerText = '点击下载文件';

document.body.appendChild(downloadLink);
```

这种方法适用于需要在前端生成文件内容的情况，比如将字符串、JSON 数据等转换为文件进行下载。

- 使用 Fetch API 和 Response 对象：

如果需要从服务器获取文件并进行下载，可以使用 Fetch API 获取文件数据，然后将数据创建为 Blob 对象，最后生成下载链接。

```js
fetch('文件的URL')
  .then(response => response.blob())
  .then(blob => {
    const url = URL.createObjectURL(blob);
    const downloadLink = document.createElement('a');
    downloadLink.href = url;
    downloadLink.download = '文件名';
    downloadLink.innerText = '点击下载文件';
    document.body.appendChild(downloadLink);
  });
```

这种方法适用于需要从服务器获取文件内容进行下载的情况。

无论你选择哪种方法，都可以根据实际情况进行调整。在使用过程中，请确保考虑到不同浏览器的兼容性以及文件类型的正确设置。

## 参考资料

[文件上传，搞懂这8种场景就够了](https://juejin.cn/post/6980142557066067982)
