## Hot Module Replacement 热模块更新

`Hot Module Replacement(HMR)`俗称热模块更新。主要用来当代码产生变化后，可以在不刷新游览器的情况下对局部代码块进行替换更新。

热模块更新表示应用在运行的过程中如果添加或删除内容不会完全刷新。这对加速我们的开发工作有重要意义。
- 完全刷新会丢失应用已有的状态
- 只更新改变的部分节约开发时间
- 在源代码中对 `CSS`/`JS` 进行修改时会立即更新浏览器内容，这几乎可以与直接在浏览器的开发工具中更改样式相媲美

## HMR 原理
### 对应用来说
- 应用程序要求 HMR 运行时检查更新。
- 运行时异步下载更新并通知应用程序。
- 然后应用程序要求运行时应用更新。
- 运行时同步应用更新。
- 可以通过设置 HMR 以便此过程自动运行，或者也可以选择需要用户交互才能发生更新。

### 对编译器 compiler 来说
除了普通资源之外，编译器还需要发出“更新”以允许从以前的版本更新到最新版本。这个“更新”由两部分组成：
- 更新后的 `manifest` (JSON)
- 一个或多个更新的 `chunk` (JavaScript)

`manifest` 包含新的 `compilation hash`和所有需要更新的 `chunk`。 这些块中的每一个都包含所有更新模块的新代码（或指示模块已删除的标志）。

编译器 `compiler` 确保 `module ID` 和 `chunk ID` 在每次构建中都保持一致。 它通常将这些 `ID` 存储在内存中（例如使用 webpack-dev-server），但也可以将它们存储在 `JSON` 文件中。

### 对于 runtime 来说
对于模块系统运行时，会有额外的代码来跟踪模块的父项和子项。在管理方面，`runtime` 支持两种方式：`check` 和 `apply`。

`check` 方法会发出 `HTTP` 请求更新的 `manifest`。如果此请求失败，则没有可用的更新。如果成功，请求到的需要更新的 `chunks` 将与当前加载的 `chunks` 进行比较。 对于每个已经加载了的 `chunks` 都会有对应的下载好的更新 `chunks`。所有模块的更新都存储在 `runtime` 中。当所有更新的 `chunks` 都已下载并准备好应用时， 会切换到就绪状态。

`apply` 方法将所有已经更新完的模块标记为无效。 对于每个无效的模块，模块或其父模块中都需要有一个处理程序。 否则，无效标志会冒泡并使父项也无效。冒泡过程会持续到到达应用程序的入口点或具有更新处理程序的模块（以先到者为准）。 如果它从入口点冒泡，则该过程失败。

最后，所有无效模块都被处理（通过处理程序）并卸载。 然后更新当前 `hash` 并调用所有接受处理程序。`runtime` 切换回空闲状态，一切照常进行。
## 参考资料
[Hot Module Replacement](https://webpack.js.org/concepts/hot-module-replacement/)