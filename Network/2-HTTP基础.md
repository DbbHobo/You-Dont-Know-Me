# HTTP

## HTTP 基础

最开始，`HTTP` 是一种不保存状态， 即无状态（stateless） 协议。 `HTTP` 协议自身不对请求和响应之间的通信状态进行保存。 也就是说在 `HTTP` 这个级别， 协议对于发送过的请求或响应都不做持久化处理。

`HTTP` 协议的初始版本中， 每进行一次 `HTTP` 通信就要断开一次 `TCP` 连接。

为解决上述 `TCP` 连接的问题， `HTTP/1.1` 和一部分的 `HTTP/1.0` 想出了**持久连接**（ HTTP Persistent Connections， 也称为 `HTTP keep-alive` 或 `HTTP connection reuse`） 的方法。 持久连接的特点是，只要任意一端没有明确提出断开连接， 则保持 `TCP` 连接状态。

在 `HTTP/1.1` 中， 所有的连接默认都是持久连接， 但在 `HTTP/1.0` 内并未标准化。

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。 从前发送请求后需等待并收到响应，才能发送下一个请求。 管线化技术出现后， 不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求， 而不需要一个接一个地等待响应了。

## HTTP 协议特点

`HTTP` 的特点概括如下:

- 灵活可扩展。主要体现在两个方面，一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。
- 可靠传输。`HTTP` 基于 `TCP/IP`，因此是可靠传输。
- 请求-应答。也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。
- 无状态。这里的状态是指通信过程的上下文信息，而每次 `HTTP` 请求都是独立、无关的，默认不需要保留状态信息。

## HTTP1.0

- 无状态

无状态是指**协议对于连接状态没有记忆能力**。纯净的 `HTTP` 是没有 `cookie` 等机制的，每一个连接都是一个新的连接。所谓的优点和缺点还是要分场景来看的，对于 `HTTP` 而言，最具争议的地方在于它的无状态。在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 `HTTP` 的缺点了。但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 `HTTP` 的优点。

- 明文传输

即协议里的报文(主要指的是头部)不使用二进制数据，而是**文本形式**。这当然对于调试提供了便利，但同时也让 `HTTP` 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI 陷阱就是利用 `HTTP` 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。

- `HTTP` 队头阻塞问题

队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。当 `HTTP` 开启长连接时，共用一个 `TCP` 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。

- 不支持服务器推送消息

---

## HTTP/1.x

`HTTP 1.x` 不允许一个连接上的多个响应数据交错到达（多路复用），因而一个响应必须完全返回后，下一个响应才会开始传输。由于 `HTTP 1.x` 不支持多路复用，浏览器可以不假思索地在客户端排队所有 `HTTP` 请求，然后通过一个持久连接，一个接一个地发送这些请求。

### 持久连接

多次请求都是通过一个连接完成的，这个连接是持久的，因而可以重用 `TCP` 连接对同一主机发送多次请求，从而实现更快的用户体验，持久化 `HTTP` 是每个 `Web` 应用的关键优化手段。

为终止持久连接，客户端的第二次请求通过 `Connection` 首部，向服务器明确发送了关闭令牌 `Connection: close`。类似地，服务器也可以在响应完成后，通知客户端自己想要关闭当前 `TCP` 连接。从技术角度讲，不发送这个令牌，任何一端也可以终止 `TCP` 连接。但为确保更好地重用连接，客户端和服务器都应该尽可能提供这个信息

### 并发TCP连接

对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在 RFC2616 规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。

限制每个主机最多 6 个连接，可以让浏览器检测出无意（或有意）的 DoS（Denial of Service）攻击。如果没有这个限制，客户端有可能消耗掉服务器的所有资源。

### 域名分片

一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。比如 `content1.test.com` 、`content2.test.com`。这样一个 `test.com` 域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。但是域名分片会因为额外的 `DNS` 查询和 `TCP` 慢启动而影响性能。

---

## HTTP/2.0

`HTTP/2`基于`SPDY`，专注于性能，最大的一个目标是**在用户和网站间只用一个连接**（connection） 。从目前的情况来看，国内外一些排名靠前的站点基本都实现了`HTTP/2`的部署，使用`HTTP/2`能带来20%~60%的效率提升。`HTTP/2`传输数据量的大幅减少，主要有两个原因：以**二进制方式传输**和**Header 压缩**。所有 `HTTP 2.0` 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。

- 流

已建立的连接上的双向字节流。

- 消息

与逻辑消息对应的完整的一系列数据帧。

- 帧

`HTTP 2.0` 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流

### 基本特征

• 所有通信都在一个 `TCP` 连接上完成。

• 流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、 2…N）。

• 消息是指逻辑上的 `HTTP` 消息，比如请求、响应等，由一或多个帧组成。

• 帧是最小的通信单位，承载着特定类型的数据，如 `HTTP` 首部、负荷，等等。

### 二进制分帧

我们先来介绍二进制传输,`HTTP/2` 采用二进制格式传输数据，而非`HTTP/1.x` 里纯文本形式的报文 ，二进制协议解析起来更高效。`HTTP/2` 将请求和响应数据分割为更小的**帧**，并且它们采用二进制编码。`HTTP/2` 认为明文传输对机器而言太麻烦了，不方便计算机的解析，因为对于文本而言会有多义性的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是 `HTTP/2` 干脆把报文全部换成**二进制**格式，全部传输 01 串，方便了机器的解析。

它把 `TCP` 协议的部分特性挪到了应用层，把原来的 `Header+Body` 的消息"打散"为数个小片的二进制"帧"(Frame),用 `Header` 帧存放头数据、 `DATA` 帧存放实体数据。`HTTP/2`数据分帧后 `Header+Body` 的报文结构就完全消失了，协议看到的只是一个个的"碎片"。

`HTTP/2` 中，**同域名下所有通信都在单个连接上完成**，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。

### 头部压缩

在 `HTTP/1.1` 及之前的时代，请求体一般会有响应的压缩编码过程，通过 `Content-Encoding` 头部字段来指定，但你有没有想过头部字段本身的压缩呢？当请求字段非常复杂的时候，尤其对于 `GET` 请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的。`HTTP/2` 针对头部字段，也采用了对应的压缩算法——`HPACK`，**对请求头进行压缩**。还有通信期间几乎不会改变的通用键－值对（用户代理、可接受的媒体类型，等等）只需发送一次。

`HPACK` 算法是专门为 `HTTP/2` 服务的，它主要的亮点有两个：

1. 首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把索引(比如 0，1，2，...)传给对方即可，对方拿到索引查表就行了。这种传索引的方式，可以说让请求头字段得到极大程度的精简和复用。

2. 其次是对于整数和字符串进行哈夫曼编码，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的索引序列，可以达到非常高的压缩率。

### 多路复用

`HTTP` 队头阻塞的问题，其根本原因在于 `HTTP` 基于**请求-响应**的模型，在同一个 `TCP` 长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。

`HTTP/2` 便从 `HTTP` 协议本身解决了队头阻塞问题。注意，这里并不是指的 `TCP` 队头阻塞，而是 `HTTP` 队头阻塞，两者并不是一回事。`TCP` 的队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面收到的报文上传给 `HTTP`，而 `HTTP` 的队头阻塞是在 `HTTP` 请求-响应层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。

原来 `Header+Body` 的报文格式如今被拆分成了一个个二进制的帧，用 `Headers` 帧存放头部字段，`Data` 帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 `HTTP` 请求报文，而是一堆**乱序的二进制帧**。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 `HTTP` 的队头阻塞问题。

通信双方都可以给对方发送**二进制帧**，这种二进制帧的**双向传输**的序列，也叫做**流(Stream)**。`HTTP/2` 用**流**来在一个 `TCP` 连接上来进行多个数据帧的通信，这就是**多路复用**的概念。

### 服务器端推送

在 `HTTP/2` 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 `stream` 来给客户端发送消息，当 `TCP` 连接建立之后，比如浏览器请求一个 `HTML` 文件，服务器就可以在返回 `HTML` 的基础上，将 `HTML` 中引用到的其他资源文件一起返回给客户端，减少客户端的等待，这被称为"服务器推送"（ Server Push，也叫 Cache push）。

服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 `RST_STREAM` 帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。

### 设置请求优先级

把 `HTTP` 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，进一步提升性能。为了做到这一点，每个流都可以带有一个 31 比特的优先值：

- 0 表示最高优先级；
- 2^31-1 表示最低优先级。

有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。具体来讲，服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。

## 参考资料

《图解HTTP》
《Web性能权威指南》
[解读 HTTP1/HTTP2/HTTP3](https://juejin.cn/post/6995109407545622542)