# TCP 协议
传输控制协议 (`TCP`) 是主要的网络协议之一。它使两台主机能够建立连接并交换数据流。TCP 能保证数据的交付，维持数据包的发送顺序。

`TCP` 是互联网的基本通信语言协议。它会校验包的交付。`TCP` 被用于 `Web` 浏览器连接到互联网时以及从一个地址向另一个地址发送文件传递电子邮件。`TCP` 确保数据传输的可靠性，并且保证每一个字节在接收时维持它们的发送顺序。操作系统通过一个编程接口来管理 `TCP`。`TCP` 使用**三次握手**来建立一个连接和**四次握手**来中断一个连接。

## TCP 工作流程

一个 `TCP` 连接通常分为三个阶段：启动、数据传输、退出。一个完整的 `TCP` 连接是**双向**和**对称**的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。

一旦建立了一个连接，这个连接的一个方向上的每个 `TCP` 报文段都包含了相反方向上的报文段的一个 `ACK`。序列号的作用是使得一个 `TCP` 接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为 `TCP` 使用 `IP` 来传输报文段，而 `IP` 不提供重复消除或者保证次序正确的功能。另一方面，`TCP` 是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此 `TCP` 接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。

`TCP` 在不可靠的信道上实现了可靠的网络传输。基本的分组**错误检测与纠正**、**按序交付**、**丢包重发**，以及保证网络最高效率的**流量控制**、**拥塞控制**和**预防机制**，让 `TCP` 成为大多数网络应用中最常见的传输协议。

## 三次握手-开启

客户端和服务端通信前要进行连接，“3 次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。

第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。

1. 客户端发送一个 `SYN` 段，并指明客户端的初始序列号，即 `ISN(c)`.
2. 服务端发送自己的 `SYN` 段作为应答，同样指明自己的 `ISN(s)`。为了确认客户端的 `SYN`，将 `ISN(c)+1` 作为 `ACK` 数值。这样，每发送一个 `SYN`，序列号就会加 1，如果有丢失的情况，则会重传。
3. 为了确认服务器端的 `SYN`，客户端将 `ISN(s)+1` 作为返回的 `ACK` 数值。

## 四次握手-结束

`TCP` 连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个 `ACK`，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个 `FIN` 段来关闭此方向上的连接。接收方发送 `ACK` 确认关闭连接。注意，接收到 `FIN` 报文的一方只能回复一个 `ACK`, 它是无法马上返回对方一个 `FIN` 报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。

1. 客户端发送一个 `FIN` 段，并包含一个希望接收者看到的自己当前的序列号 K. 同时还包含一个 `ACK` 表示确认对方最近一次发过来的数据。
2. 服务端将 K 值加 1 作为 `ACK` 序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。
3. 服务端发起自己的 `FIN` 段，`ACK=K+1`, `Seq=L`。
4. 客户端确认。`ACK=L+1`。

## 序列号 ISN

ISN = M + F(localhost, localport, remotehost, remoteport)

M 是一个计时器，每隔 4 毫秒加 1。 F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。

`TCP` 对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。

## TCP 队头阻塞

`TCP` 的阻塞问题是因为传输阶段可能会丢包，`TCP` 是一个**按序传输**的通道,一旦丢包就会等待重新发包，阻塞后续内容传输。每个 `TCP` 分组都会带着一个唯一的序号被发出，而所有分组必须按顺序传送到接收端。如果中途有一个分组没能到达接收端，那么后续分组必须保存在接收端的 `TCP` 缓冲区上，等待丢失分组重发并到达接收端。应用程序对 `TCP` 重发和缓冲区中排队的分组一无所知，必须等待分组全部到达才能访问数据。在此之前，应用程序只能在通过套接字读数据时感觉到延迟交付。这就是 `TCP` 的队首阻塞。

## 参考资料
[“三次握手，四次挥手”你真的懂吗？](https://zhuanlan.zhihu.com/p/53374516)
