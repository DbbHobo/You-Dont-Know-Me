# Generator Async

## 进程

计算机的核心是 CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个 CPU 一次只能运行一个任务。进程就好比工厂的车间，它代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。

## 线程

JS 是**单线程**运行的。

## 协程

协程是一种比线程更加轻量级的存在，协程处在线程的环境中，**一个线程可以存在多个协程**，可以将协程理解为线程中的一个个任务。不同于进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。

## 同步 异步

**异步**，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。

**同步**，相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。

## Iterator 遍历器

遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员），比如 `for...of`。

一个对象如果要具备可被 `for...of` 循环调用的 Iterator 接口，就必须在 `Symbol.iterator` 的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。

## async

async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。

async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。

带 async 关键字的函数，它使得你的函数的返回值必定是 **promise 对象**；如果 async 关键字函数返回的不是 promise，会自动用 `Promise.resolve()` 包装；如果 async 关键字函数显式地返回 promise，那就以你返回的 promise 为准。

async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。

async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。

async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。

[进程与线程的一个简单解释](https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)
[Generator 函数的异步应用](https://es6.ruanyifeng.com/?search=map%28parseInt%29&x=0&y=0#docs/generator-async#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
[😇 原生 JS 灵魂之问(下), 冲刺 🚀 进阶最后一公里(神三元)](https://juejin.im/post/6844904004007247880#heading-55)
